import math
import random
import csv
import psutil
from tqdm import tqdm
import os
import time

MAX_ITERATIONS = 100000  # Or some other suitable number based on your requirements


# Define the cooling schedules
def geometric_cooling(current_temp, cooling_rate):
    return current_temp * cooling_rate


def boltzmann_cooling(current_temp, k, iteration):
    return current_temp / math.log(iteration + k)


# Define initial temperature strategie
def fixed_temperature(value):
    return value


# Define solution choice strategies
def greedy_initial_solution(distance_matrix):
    # Starts at the first city and always goes to the nearest city not yet visited
    n = len(distance_matrix)
    start = 0  # Can be randomized or selected by some criteria
    unvisited = set(range(n))
    unvisited.remove(start)
    solution = [start]

    current_city = start
    while unvisited:
        next_city = min(unvisited, key=lambda city: distance_matrix[current_city][city])
        unvisited.remove(next_city)
        solution.append(next_city)
        current_city = next_city

    return solution


# Define neighborhood exploration strategies
def get_neighborhood(solution):
    # Generate all possible 2-opt neighbors of the current solution
    neighbors = []
    for i in range(1, len(solution) - 2):
        for j in range(i + 1, len(solution)):
            if j - i == 1:
                continue  # this would be a no-op change
            new_solution = solution[:i] + solution[j : i - 1 : -1] + solution[j + 1 :]
            neighbors.append(new_solution)
    return neighbors


# Define swap strategies
def two_opt_swap(solution):
    # Randomly pick two edges and perform a 2-opt swap
    city1 = random.randint(1, len(solution) - 2)
    city2 = random.randint(city1 + 1, len(solution) - 1)

    new_solution = solution[:city1] + solution[city1:city2][::-1] + solution[city2:]
    return new_solution


def subset_shuffle_swap(solution):
    # Randomly choose two indices to determine the subset to shuffle
    start = random.randint(0, len(solution) - 2)
    end = random.randint(start + 1, len(solution) - 1)

    # Extract the subset and shuffle it
    subset = solution[start:end]
    random.shuffle(subset)

    # Replace the original subset with the shuffled subset
    new_solution = solution[:start] + subset + solution[end:]

    return new_solution


# SA implementation
def simulated_annealing(distance_matrix, initial_temp, cooling_schedule, swap_strategy, initial_solution, epoch_length):
    current_solution = initial_solution
    current_temp = initial_temp
    best_solution = current_solution
    best_cost = calculate_cost(distance_matrix, best_solution)
    iteration = 0

    while not stopping_condition(current_temp, iteration):
        for _ in range(epoch_length):  # Iterate for epoch_length times before cooling
            new_solution = swap_strategy(current_solution)
            new_cost = calculate_cost(distance_matrix, new_solution)
            cost_difference = new_cost - best_cost

            if (
                cost_difference < 0
                or math.exp(-cost_difference / current_temp) > random.random()
            ):
                current_solution = new_solution
                if new_cost < best_cost:
                    best_solution = new_solution
                    best_cost = new_cost

            current_temp = cooling_schedule(current_temp, iteration)
            iteration += 1

    return best_cost, best_solution  # Return both cost and path


def calculate_cost(distance_matrix, path):
    cost = 0
    print(f"Path: {path}")  # Debug print
    print(
        f"Distance matrix size: {len(distance_matrix)}x{len(distance_matrix[0])}"
    )  # Debug print
    for i in range(1, len(path)):
        print(f"Processing edge from {path[i - 1]} to {path[i]}")  # Debug print
        if path[i - 1] >= len(distance_matrix) or path[i] >= len(distance_matrix):
            raise IndexError(
                f"City index out of range: {path[i-1]} or {path[i]} not in distance matrix."
            )
        if path[i - 1] < 0 or path[i] < 0:
            raise IndexError(
                f"City index cannot be negative: {path[i-1]} or {path[i]}."
            )
        cost += distance_matrix[path[i - 1]][path[i]]
    # Add the distance to return to the start for a closed loop TSP
    if path:
        print(f"Returning to start from {path[-1]} to {path[0]}")  # Debug print
        cost += distance_matrix[path[-1]][path[0]]
    return cost


# Define stopping condition
def stopping_condition(current_temp, iteration):
    # Implement the stopping condition for the simulated annealing
    return current_temp < 1 or iteration > MAX_ITERATIONS


# Define a dictionary to map strategy names to functions
cooling_schedules = {
    "geometric_cooling": geometric_cooling,
    "boltzmann_cooling": boltzmann_cooling,
    # Add more cooling schedules as needed
}

swap_strategies = {
    "two_opt_swap": two_opt_swap,
    "subset_shuffle_swap": subset_shuffle_swap,
    # Add more swap strategies as needed
}


def parse_config(config_file):
    tsp_instances = []
    settings = {
        "cooling_temperature": None,
        "cooling_schedule": None,
        "swap_strategy": None,
    }
    with open(config_file, "r") as file:
        lines = file.readlines()
        # Assume the first line contains the cooling temperature
        for setting_line in lines[:3]:  # Assuming the first 3 lines are settings
            if "=" in setting_line:
                key, value = setting_line.strip().split("=")
                settings[key] = value.strip()

        for line in lines[3:]:
            parts = line.split()
            if parts:  # skip empty lines
                instance = {
                    "file_name": parts[0],
                    "times_to_run": int(parts[1]),
                    "number_of_instances": int(parts[2]),
                    # ... include additional parameters as needed
                }
            tsp_instances.append(instance)
    return settings, tsp_instances


def read_tsp_data(filename):
    full_path = os.path.join("data", filename)
    with open(full_path, "r") as file:
        lines = file.read().splitlines()
        size = int(lines[0])
        matrix = []
        for line in lines[1:]:
            matrix.append(list(map(int, line.split())))
        return matrix


# Main function to run the program
def main():
    # Main function to run the program
    config_file = "config.ini"
    settings, tsp_instances = parse_config(config_file)
    initial_temp = fixed_temperature(float(settings['cooling_temperature']))
    initial_solution_strategy = greedy_initial_solution
    # Define a range of epoch lengths to test
    epoch_lengths = [10, 50, 100, 500, 1000]
    # Specify the correct delimiter here, if your system expects something other than a comma
    delimiter = ","

    # Open the CSV file in write mode
    with open("tsp_sa_results.csv", mode="w", newline="") as file:
        writer = csv.writer(
            file, delimiter=delimiter, quotechar='"', quoting=csv.QUOTE_MINIMAL
        )

        # Write the header if the file is new/empty
        writer.writerow(["instance", "time", "cost", "path", "peak_memory_usage_in_MB"])
        # Load or define your distance matrix
        for epoch_length in epoch_lengths:
            writer.writerow(epoch_length)
            for instance in tsp_instances:
                distance_matrix = read_tsp_data(instance["file_name"])
                initial_solution = initial_solution_strategy(distance_matrix)
                for _ in tqdm(
                    range(instance["times_to_run"]),
                    desc=f"Processing {instance['file_name']}",
                ):
                    # Set up the parameters for simulated annealing
                    selected_cooling_schedule = cooling_schedules[
                        settings["cooling_schedule"]
                    ]
                    selected_swap_strategy = swap_strategies[settings["swap_strategy"]]
                    # Start SA
                    start_time = time.time_ns()
                    initial_memory = psutil.Process().memory_info().rss

                    cost, path = simulated_annealing(
                        distance_matrix=distance_matrix,
                        initial_temp=initial_temp,
                        cooling_schedule=selected_cooling_schedule,
                        swap_strategy=selected_swap_strategy,
                        initial_solution=initial_solution,
                        epoch_length=epoch_length
                    )

                    peak_memory = psutil.Process().memory_info().rss
                    end_time = time.time_ns()

                    # Calculate execution time in microseconds
                    execution_time_ns = end_time - start_time

                    # Calculate peak memory usage in MB
                    peak_memory_usage_mb = (peak_memory - initial_memory) / 1024 / 1024

                    # Format the path as a string if necessary
                    path_str = "-".join(map(str, path))

                    # Write the result immediately to the CSV file
                    writer.writerow(
                        [
                            instance["file_name"],
                            execution_time_ns,
                            cost,
                            path_str,
                            peak_memory_usage_mb,
                        ]
                    )


if __name__ == "__main__":
    main()
